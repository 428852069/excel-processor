<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ¨çº¿è¡¨æ ¼è‡ªåŠ¨åŒ–å¤„ç†ä¸­å¿ƒ</title>
    <!-- å¼•å…¥ Handsontable çš„æ ·å¼æ–‡ä»¶ -->
    <link href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css" rel="stylesheet">
    <style>
        * { box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        body { margin: 20px; background-color: #f5f7fa; color: #333; }
        .container { max-width: 1800px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); padding: 25px; }
        header { text-align: center; margin-bottom: 30px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        header h1 { color: #2c3e50; margin-bottom: 5px; }
        header p { color: #7f8c8d; font-size: 1.1em; }

        /* åŠŸèƒ½åŒºæ ·å¼ */
        .control-panel { display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 25px; padding: 20px; background: #f8f9fa; border-radius: 6px; align-items: center; }
        .btn { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #1e7e34; }
        .btn-warning { background-color: #ffc107; color: #212529; }
        .btn-warning:hover { background-color: #d39e00; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-danger:hover { background-color: #bd2130; }
        .file-input-wrapper { flex-grow: 1; }
        .file-input-wrapper input[type="file"] { padding: 8px; border: 1px solid #ddd; border-radius: 5px; width: 100%; }

        /* å·¥å…·æ æ ·å¼ */
        .toolbar { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; padding: 15px; background: #e9ecef; border-radius: 6px; }
        .toolbar-label { font-weight: bold; color: #495057; margin-right: 10px; align-self: center; }

        /* è¡¨æ ¼ç¼–è¾‘åŒºæ ·å¼ */
        #excelEditorContainer { height: 700px; margin-bottom: 20px; border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }

        /* æäº¤ä¸ä¸‹è½½åŒº */
        .submit-area { text-align: center; padding-top: 20px; border-top: 1px solid #eee; }
        .instructions { background-color: #e7f3ff; padding: 15px; border-radius: 6px; margin-top: 20px; border-left: 4px solid #007bff; }
        .instructions p { margin: 5px 0; font-size: 0.95em; }
        
        /* çŠ¶æ€æç¤º */
        .status { padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 0.9em; }
        .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status-info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        
        /* æ ¼å¼å·¥å…·æ  */
        .format-toolbar { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px; }
        .format-group { display: flex; align-items: center; gap: 5px; border-right: 1px solid #ccc; padding-right: 10px; }
        .format-group:last-child { border-right: none; }
        .format-btn { padding: 6px 12px; background: white; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
        .format-btn:hover { background: #e9ecef; }
        .color-picker { width: 30px; height: 30px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ“Š åœ¨çº¿è¡¨æ ¼è‡ªåŠ¨åŒ–å¤„ç†ä¸­å¿ƒ</h1>
            <p>ä¸Šä¼ Excelæ–‡ä»¶ï¼Œä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·å¤„ç†ï¼Œç¼–è¾‘åä¸€é”®æäº¤</p>
        </header>

        <!-- çŠ¶æ€æç¤ºåŒºåŸŸ -->
        <div id="statusArea"></div>

        <!-- 1. ä¸Šä¼ æ–‡ä»¶åŒº -->
        <div class="control-panel">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".xlsx">
            </div>
            <button onclick="document.getElementById('fileInput').click()" class="btn btn-primary">ğŸ“ é€‰æ‹©Excelæ–‡ä»¶ (.xlsx)</button>
            <button onclick="saveFile()" class="btn btn-success">ğŸ’¾ ä¸‹è½½å½“å‰è¡¨æ ¼</button>
            <button onclick="clearData()" class="btn btn-danger">ğŸ—‘ï¸ æ¸…ç©ºè¡¨æ ¼</button>
        </div>

        <!-- æ ¼å¼å·¥å…·æ  -->
        <div class="format-toolbar">
            <div class="format-group">
                <span>å­—ä½“ï¼š</span>
                <select id="fontFamily" class="format-btn" onchange="applyFontFamily(this.value)">
                    <option value="ä»¿å®‹">ä»¿å®‹</option>
                    <option value="é»‘ä½“">é»‘ä½“</option>
                    <option value="å¾®è½¯é›…é»‘">å¾®è½¯é›…é»‘</option>
                    <option value="å®‹ä½“">å®‹ä½“</option>
                </select>
                <select id="fontSize" class="format-btn" onchange="applyFontSize(this.value)">
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="14">14</option>
                    <option value="16">16</option>
                </select>
            </div>
            <div class="format-group">
                <button class="format-btn" onclick="applyBold()"><b>B</b></button>
                <button class="format-btn" onclick="applyItalic()"><i>I</i></button>
                <button class="format-btn" onclick="applyUnderline()"><u>U</u></button>
            </div>
            <div class="format-group">
                <span>å¯¹é½ï¼š</span>
                <button class="format-btn" onclick="applyAlignment('left')">å·¦</button>
                <button class="format-btn" onclick="applyAlignment('center')">ä¸­</button>
                <button class="format-btn" onclick="applyAlignment('right')">å³</button>
            </div>
            <div class="format-group">
                <span>èƒŒæ™¯ï¼š</span>
                <input type="color" id="bgColor" class="color-picker" onchange="applyBackgroundColor(this.value)">
            </div>
            <div class="format-group">
                <span>æ–‡å­—ï¼š</span>
                <input type="color" id="textColor" class="color-picker" value="#000000" onchange="applyTextColor(this.value)">
            </div>
            <div class="format-group">
                <span>è¾¹æ¡†ï¼š</span>
                <button class="format-btn" onclick="applyBorder('all')">å…¨è¾¹æ¡†</button>
                <button class="format-btn" onclick="applyBorder('outer')">å¤–è¾¹æ¡†</button>
            </div>
            <div class="format-group">
                <button class="format-btn" onclick="applyMerge()">åˆå¹¶å•å…ƒæ ¼</button>
                <button class="format-btn" onclick="applyUnmerge()">å–æ¶ˆåˆå¹¶</button>
            </div>
        </div>

        <!-- 2. å·¥å…·æ ï¼ˆå››ä¸ªè‡ªåŠ¨åŒ–è„šæœ¬æŒ‰é’®ï¼‰ -->
        <div class="toolbar">
            <div class="toolbar-label">ğŸ”§ è‡ªåŠ¨åŒ–å·¥å…·ï¼š</div>
            <button onclick="checkAge()" class="btn btn-warning">æ£€éªŒæ˜¯å¦æ»¡14å‘¨å²</button>
            <button onclick="markLeague()" class="btn btn-warning">è‡ªåŠ¨æ ‡è®°æ˜¯å¦å…¥å›¢</button>
            <button onclick="markGraduation()" class="btn btn-warning">è‡ªåŠ¨æ ‡è®°æ˜¯å¦æ¯•ä¸š</button>
            <button onclick="checkActivity()" class="btn btn-warning">æ£€éªŒå…‰å±±å¿è·¨æ ¡ç§¯æåˆ†å­</button>
        </div>

        <!-- 3. è¡¨æ ¼ç¼–è¾‘åŒºï¼ˆæ ¸å¿ƒåŒºåŸŸï¼‰ -->
        <h3>åœ¨çº¿ç¼–è¾‘åŒº</h3>
        <div id="excelEditorContainer"></div>

        <!-- 4. æäº¤ä¸ä¸‹è½½åŒº -->
        <div class="submit-area">
            <button onclick="submitToCollectForm()" class="btn btn-success" style="padding: 12px 30px; font-size: 1.1em;">
                âœ… å¤„ç†å®Œæˆï¼Œç‚¹å‡»æäº¤
            </button>
            <p style="color:#6c757d; margin-top: 8px;">ç‚¹å‡»åï¼Œå°†è‡ªåŠ¨è·³è½¬åˆ°æ–‡ä»¶æ”¶é›†é¡µé¢</p>
        </div>

        <!-- 5. ä½¿ç”¨è¯´æ˜ -->
        <div class="instructions">
            <p><strong>ä½¿ç”¨æµç¨‹ï¼š</strong></p>
            <p>1. ç‚¹å‡»"é€‰æ‹©Excelæ–‡ä»¶"æŒ‰é’®ä¸Šä¼ æ–‡ä»¶ â†’ 2. è¡¨æ ¼è‡ªåŠ¨åŠ è½½å¹¶åº”ç”¨æ ‡å‡†æ ¼å¼ â†’ 3. ä½¿ç”¨ä¸Šæ–¹å·¥å…·æ ç¼–è¾‘æ ¼å¼ â†’ 4. ä½¿ç”¨è‡ªåŠ¨åŒ–å·¥å…·å¤„ç† â†’ 5. ç‚¹å‡»"ä¸‹è½½å½“å‰è¡¨æ ¼"å¤‡ä»½ â†’ 6. ç‚¹å‡»"æäº¤"æŒ‰é’®è·³è½¬åˆ°æ”¶é›†è¡¨ä¸Šä¼ </p>
            <p><strong>æ³¨æ„ï¼š</strong>å‰4è¡Œä¸ºå›ºå®šæ ¼å¼ï¼Œç¬¬5è¡Œå¿…é¡»ä¸ºè¡¨å¤´è¡Œï¼ˆåŒ…å«"åºå·"å’Œ"æ‰¹æ¬¡"ï¼‰ã€‚</p>
        </div>
    </div>

    <!-- å¼•å…¥ SheetJS åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- å¼•å…¥ Handsontable åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
    <!-- å¼•å…¥ä¸­æ–‡è¯­è¨€åŒ… -->
    <script src="https://cdn.jsdelivr.net/npm/handsontable/languages/zh-CN.min.js"></script>

    <script>
        // --- å…¨å±€å˜é‡ ---
        let hot; // Handsontable å®ä¾‹
        let currentData = []; // å½“å‰è¡¨æ ¼æ•°æ®
        let currentFileName = '';
        let columnHeaders = []; // å­˜å‚¨åˆ—æ ‡é¢˜
        let isFormatApplied = false; // æ ‡è®°æ˜¯å¦å·²åº”ç”¨æ ¼å¼
        const columnWidths = { // åˆ—å®½å®šä¹‰ï¼ˆå­—ç¬¦æ•° * 8 â‰ˆ åƒç´ ï¼‰
            'A': 8 * 8, 'B': 16 * 8, 'C': 8 * 8, 'D': 8 * 8, 'E': 30 * 8,
            'F': 11 * 8, 'G': 12 * 8, 'H': 8 * 8, 'I': 25 * 8, 'J': 8 * 8,
            'K': 8 * 8, 'L': 12 * 8, 'M': 12 * 8, 'N': 12 * 8, 'O': 12 * 8,
            'P': 12 * 8, 'Q': 30 * 8, 'R': 12 * 8, 'S': 30 * 8, 'T': 12 * 8
        };

        // --- çŠ¶æ€æç¤ºå‡½æ•° ---
        function showStatus(message, type = 'info') {
            const statusArea = document.getElementById('statusArea');
            statusArea.innerHTML = `<div class="status status-${type}">${message}</div>`;
            setTimeout(() => {
                if (statusArea.firstChild) {
                    statusArea.firstChild.style.opacity = '0';
                    setTimeout(() => statusArea.innerHTML = '', 3000);
                }
            }, 3000);
        }

        // --- æ ¼å¼éªŒè¯å‡½æ•° ---
        function validateTableFormat(data) {
            if (data.length < 5) {
                return { valid: false, message: "è¡¨æ ¼è¡Œæ•°ä¸è¶³5è¡Œ" };
            }
            
            // æ£€æŸ¥A5å’ŒB5å•å…ƒæ ¼
            const a5Value = data[4] && data[4][0] ? data[4][0].toString().trim() : '';
            const b5Value = data[4] && data[4][1] ? data[4][1].toString().trim() : '';
            
            if (a5Value !== 'åºå·' || b5Value !== 'æ‰¹æ¬¡') {
                return { 
                    valid: false, 
                    message: "è¡¨æ ¼ä¸ç¬¦åˆè¦æ±‚ï¼Œè¯·å‹¿åˆ é™¤æˆ–æ›´æ”¹è¡¨å¤´åŒºåŸŸï¼ˆå‰5è¡Œï¼‰ï¼Œå¦åˆ™ç³»ç»Ÿå°†ä¸èƒ½åœ¨ç¬¬5è¡Œæ£€æµ‹åˆ°è¡¨å¤´ã€‚\næ£€æµ‹ç»“æœï¼šA5=" + a5Value + ", B5=" + b5Value
                };
            }
            
            return { valid: true, message: "è¡¨æ ¼æ ¼å¼éªŒè¯é€šè¿‡" };
        }

        // --- åº”ç”¨æ ‡å‡†æ ¼å¼å‡½æ•° ---
        function applyStandardFormat() {
            if (!hot || hot.countRows() === 0) return;
            
            const totalRows = hot.countRows();
            const totalCols = hot.countCols();
            
            // é‡ç½®æ‰€æœ‰æ ¼å¼
            hot.updateSettings({
                cell: []
            });
            
            // 1. è®¾ç½®è¡¨å¤´è¡Œï¼ˆç¬¬5è¡Œï¼Œç´¢å¼•4ï¼‰çš„æ ¼å¼
            for (let col = 0; col < totalCols; col++) {
                // ç¬¬5è¡Œï¼šé»‘ä½“ã€14å·ã€è‡ªåŠ¨æ¢è¡Œã€å±…ä¸­
                hot.setCellMeta(4, col, 'className', 'header-row');
                hot.setCellMeta(4, col, 'renderer', function(instance, td, row, col, prop, value, cellProperties) {
                    Handsontable.renderers.TextRenderer.apply(this, arguments);
                    td.style.fontFamily = 'é»‘ä½“';
                    td.style.fontSize = '14px';
                    td.style.fontWeight = 'bold';
                    td.style.textAlign = 'center';
                    td.style.verticalAlign = 'middle';
                    td.style.whiteSpace = 'normal';
                    td.style.wordWrap = 'break-word';
                    td.style.border = '1px solid #000';
                    td.style.backgroundColor = '#f2f2f2';
                });
                
                // å…¶ä»–è¡Œï¼šä»¿å®‹ã€11å·ã€ä¸æ¢è¡Œã€å±…ä¸­
                for (let row = 5; row < totalRows; row++) {
                    hot.setCellMeta(row, col, 'className', 'data-row');
                    hot.setCellMeta(row, col, 'renderer', function(instance, td, row, col, prop, value, cellProperties) {
                        Handsontable.renderers.TextRenderer.apply(this, arguments);
                        td.style.fontFamily = 'ä»¿å®‹';
                        td.style.fontSize = '11px';
                        td.style.textAlign = 'center';
                        td.style.verticalAlign = 'middle';
                        td.style.whiteSpace = 'nowrap';
                        td.style.overflow = 'hidden';
                        td.style.textOverflow = 'ellipsis';
                        td.style.border = '1px solid #ccc';
                    });
                }
            }
            
            // 2. è®¾ç½®è¡Œé«˜
            for (let row = 0; row < totalRows; row++) {
                if (row === 4) { // ç¬¬5è¡Œ
                    hot.setCellMeta(row, 0, 'rowHeight', 80);
                } else if (row >= 5) { // ç¬¬6è¡Œå¼€å§‹
                    hot.setCellMeta(row, 0, 'rowHeight', 20);
                }
            }
            
            // 3. è®¾ç½®åˆ—å®½
            for (let col = 0; col < totalCols; col++) {
                const colLetter = String.fromCharCode(65 + col);
                const width = columnWidths[colLetter] || 100;
                hot.setCellMeta(0, col, 'colWidths', width);
            }
            
            // 4. åº”ç”¨è¾¹æ¡†ï¼ˆä»ç¬¬5è¡Œå¼€å§‹ï¼‰
            for (let row = 4; row < totalRows; row++) {
                for (let col = 0; col < totalCols; col++) {
                    const cellMeta = hot.getCellMeta(row, col);
                    if (!cellMeta.className) cellMeta.className = '';
                    cellMeta.className += ' bordered';
                }
            }
            
            // 5. å‰4è¡Œä¿æŒåŸæ ·ï¼ˆä¸åº”ç”¨æ ‡å‡†æ ¼å¼ï¼‰
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < totalCols; col++) {
                    hot.setCellMeta(row, col, 'renderer', function(instance, td, row, col, prop, value, cellProperties) {
                        Handsontable.renderers.TextRenderer.apply(this, arguments);
                        td.style.border = 'none';
                    });
                }
            }
            
            hot.render();
            isFormatApplied = true;
            showStatus('æ ‡å‡†æ ¼å¼å·²åº”ç”¨', 'success');
        }

        // --- æ ¼å¼å·¥å…·æ åŠŸèƒ½ ---
        function applyFontFamily(font) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.fontFamily = font;
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.fontFamily = font;
                        };
                    }
                }
            }
            hot.render();
        }

        function applyFontSize(size) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.fontSize = size + 'px';
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.fontSize = size + 'px';
                        };
                    }
                }
            }
            hot.render();
        }

        function applyBold() {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.fontWeight = td.style.fontWeight === 'bold' ? 'normal' : 'bold';
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.fontWeight = td.style.fontWeight === 'bold' ? 'normal' : 'bold';
                        };
                    }
                }
            }
            hot.render();
        }

        function applyItalic() {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.fontStyle = td.style.fontStyle === 'italic' ? 'normal' : 'italic';
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.fontStyle = td.style.fontStyle === 'italic' ? 'normal' : 'italic';
                        };
                    }
                }
            }
            hot.render();
        }

        function applyUnderline() {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.textDecoration = td.style.textDecoration === 'underline' ? 'none' : 'underline';
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.textDecoration = td.style.textDecoration === 'underline' ? 'none' : 'underline';
                        };
                    }
                }
            }
            hot.render();
        }

        function applyAlignment(align) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.textAlign = align;
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.textAlign = align;
                        };
                    }
                }
            }
            hot.render();
        }

        function applyBackgroundColor(color) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.backgroundColor = color;
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.backgroundColor = color;
                        };
                    }
                }
            }
            hot.render();
        }

        function applyTextColor(color) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            td.style.color = color;
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            td.style.color = color;
                        };
                    }
                }
            }
            hot.render();
        }

        function applyBorder(type) {
            const selected = hot.getSelected();
            if (!selected) return;
            
            for (let r = selected[0]; r <= selected[2]; r++) {
                for (let c = selected[1]; c <= selected[3]; c++) {
                    const cellMeta = hot.getCellMeta(r, c);
                    if (!cellMeta.renderer) {
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            Handsontable.renderers.TextRenderer.apply(this, arguments);
                            if (type === 'all') {
                                td.style.border = '1px solid #000';
                            } else if (type === 'outer') {
                                if (r === selected[0]) td.style.borderTop = '2px solid #000';
                                if (r === selected[2]) td.style.borderBottom = '2px solid #000';
                                if (c === selected[1]) td.style.borderLeft = '2px solid #000';
                                if (c === selected[3]) td.style.borderRight = '2px solid #000';
                            }
                        };
                    } else {
                        const originalRenderer = cellMeta.renderer;
                        cellMeta.renderer = function(instance, td, row, col, prop, value, cellProperties) {
                            originalRenderer.call(this, instance, td, row, col, prop, value, cellProperties);
                            if (type === 'all') {
                                td.style.border = '1px solid #000';
                            } else if (type === 'outer') {
                                if (r === selected[0]) td.style.borderTop = '2px solid #000';
                                if (r === selected[2]) td.style.borderBottom = '2px solid #000';
                                if (c === selected[1]) td.style.borderLeft = '2px solid #000';
                                if (c === selected[3]) td.style.borderRight = '2px solid #000';
                            }
                        };
                    }
                }
            }
            hot.render();
        }

        function applyMerge() {
            const selected = hot.getSelected();
            if (!selected || (selected[0] === selected[2] && selected[1] === selected[3])) return;
            
            hot.mergeCells({
                row: selected[0],
                col: selected[1],
                rowspan: selected[2] - selected[0] + 1,
                colspan: selected[3] - selected[1] + 1
            });
        }

        function applyUnmerge() {
            const selected = hot.getSelected();
            if (!selected) return;
            
            hot.unmergeCells(selected[0], selected[1], selected[2], selected[3]);
        }

        // --- Handsontable åˆå§‹åŒ–ï¼ˆä¸­æ–‡ç•Œé¢ï¼‰---
        document.addEventListener('DOMContentLoaded', function () {
            const container = document.getElementById('excelEditorContainer');
            
            // é…ç½®ä¸­æ–‡ä¸Šä¸‹æ–‡èœå•
            const contextMenuItems = {
                'row_above': { name: 'ä¸Šæ–¹æ’å…¥è¡Œ' },
                'row_below': { name: 'ä¸‹æ–¹æ’å…¥è¡Œ' },
                'col_left': { name: 'å·¦ä¾§æ’å…¥åˆ—' },
                'col_right': { name: 'å³ä¾§æ’å…¥åˆ—' },
                'remove_row': { name: 'åˆ é™¤è¡Œ' },
                'remove_col': { name: 'åˆ é™¤åˆ—' },
                'alignment': { name: 'å¯¹é½æ–¹å¼' },
                'mergeCells': { name: 'åˆå¹¶å•å…ƒæ ¼' },
                'undo': { name: 'æ’¤é”€' },
                'redo': { name: 'é‡åš' },
                'copy': { name: 'å¤åˆ¶' },
                'cut': { name: 'å‰ªåˆ‡' },
                'freeze_column': { name: 'å†»ç»“åˆ—' },
                'unfreeze_column': { name: 'å–æ¶ˆå†»ç»“åˆ—' },
                'filter_by_condition': { name: 'æ¡ä»¶ç­›é€‰' },
                'filter_by_value': { name: 'å€¼ç­›é€‰' },
                'filter_action_bar': { name: 'ç­›é€‰å·¥å…·æ ' }
            };
            
            hot = new Handsontable(container, {
                data: [],
                rowHeaders: true,
                colHeaders: true,
                height: '100%',
                width: '100%',
                licenseKey: 'non-commercial-and-evaluation',
                language: Handsontable.languages['zh-CN'],
                contextMenu: {
                    items: contextMenuItems
                },
                filters: true, // å¯ç”¨ç­›é€‰åŠŸèƒ½
                dropdownMenu: ['filter_by_condition', 'filter_by_value', 'filter_action_bar'],
                manualRowResize: true,
                manualColumnResize: true,
                manualRowMove: true,
                manualColumnMove: true,
                columnSorting: true,
                mergeCells: true, // å¯ç”¨åˆå¹¶å•å…ƒæ ¼
                stretchH: 'all',
                wordWrap: false,
                columns: null,
                colWidths: null,
                afterChange: function(changes, source) {
                    if (source === 'loadData') return;
                    currentData = hot.getSourceData();
                },
                afterRender: function() {
                    if (!isFormatApplied && hot.countRows() >= 5) {
                        applyStandardFormat();
                    }
                }
            });

            // æ–‡ä»¶é€‰æ‹©ç›‘å¬
            document.getElementById('fileInput').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    loadFile();
                }
            });

            showStatus('è¡¨æ ¼ç¼–è¾‘å™¨å·²å‡†å¤‡å°±ç»ªï¼Œè¯·é€‰æ‹©.xlsxæ–‡ä»¶å¼€å§‹ä½¿ç”¨ã€‚', 'info');
        });

        // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---

        // 1. åŠ è½½Excelæ–‡ä»¶åˆ°è¡¨æ ¼
        function loadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªExcelæ–‡ä»¶', 'error');
                return;
            }

            // æ£€æŸ¥æ–‡ä»¶ç±»å‹
            if (!file.name.toLowerCase().endsWith('.xlsx')) {
                showStatus('åªæ”¯æŒ .xlsx æ ¼å¼çš„æ–‡ä»¶ï¼Œè¯·é‡æ–°é€‰æ‹©', 'error');
                fileInput.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    showStatus('æ­£åœ¨è§£ææ–‡ä»¶ï¼Œè¯·ç¨å€™...', 'info');
                    
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { 
                        type: 'array',
                        cellDates: true,
                        cellStyles: true,
                        raw: false
                    });
                    
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // è·å–å·¥ä½œè¡¨èŒƒå›´
                    const range = XLSX.utils.decode_range(worksheet['!ref']);
                    const totalRows = range.e.r + 1;
                    const totalCols = range.e.c + 1;
                    
                    // è½¬æ¢ä¸ºäºŒç»´æ•°ç»„
                    let jsonData = [];
                    for (let R = range.s.r; R <= range.e.r; ++R) {
                        const row = [];
                        for (let C = range.s.c; C <= range.e.c; ++C) {
                            const cell_address = {c: C, r: R};
                            const cell_ref = XLSX.utils.encode_cell(cell_address);
                            const cell = worksheet[cell_ref];
                            
                            if (cell) {
                                // ä¿ç•™åŸå§‹å€¼
                                row.push(cell.v);
                                
                                // è®°å½•åˆå¹¶å•å…ƒæ ¼ä¿¡æ¯
                                if (cell_address.r < 4) { // å‰4è¡Œ
                                    // æ£€æŸ¥æ˜¯å¦æ˜¯åˆå¹¶å•å…ƒæ ¼çš„ä¸€éƒ¨åˆ†
                                    if (worksheet['!merges']) {
                                        worksheet['!merges'].forEach(merge => {
                                            if (cell_address.r >= merge.s.r && cell_address.r <= merge.e.r &&
                                                cell_address.c >= merge.s.c && cell_address.c <= merge.e.c) {
                                                // è¿™æ˜¯åˆå¹¶å•å…ƒæ ¼
                                                hot.mergeCells({
                                                    row: merge.s.r,
                                                    col: merge.s.c,
                                                    rowspan: merge.e.r - merge.s.r + 1,
                                                    colspan: merge.e.c - merge.s.c + 1
                                                });
                                            }
                                        });
                                    }
                                }
                            } else {
                                row.push('');
                            }
                        }
                        jsonData.push(row);
                    }
                    
                    // éªŒè¯è¡¨æ ¼æ ¼å¼
                    const validation = validateTableFormat(jsonData);
                    if (!validation.valid) {
                        showStatus(validation.message, 'error');
                        fileInput.value = '';
                        return;
                    }
                    
                    // ä¿å­˜åˆ—æ ‡é¢˜
                    columnHeaders = jsonData[4] || [];
                    
                    // åŠ è½½æ•°æ®åˆ°è¡¨æ ¼
                    hot.loadData(jsonData);
                    currentData = jsonData;
                    currentFileName = file.name.replace(/\.[^/.]+$/, "");
                    
                    // é‡ç½®æ ¼å¼æ ‡è®°
                    isFormatApplied = false;
                    
                    // è®¾ç½®åˆ—æ ‡é¢˜
                    if (columnHeaders.length > 0) {
                        hot.updateSettings({
                            colHeaders: columnHeaders
                        });
                    }
                    
                    // åº”ç”¨æ ‡å‡†æ ¼å¼
                    setTimeout(() => {
                        applyStandardFormat();
                    }, 100);
                    
                    showStatus(`âœ… æ–‡ä»¶"${file.name}"åŠ è½½æˆåŠŸï¼è¡¨æ ¼æ ¼å¼éªŒè¯é€šè¿‡ï¼Œæ ‡å‡†æ ¼å¼å·²åº”ç”¨ã€‚`, 'success');
                    
                } catch (error) {
                    console.error('è§£æé”™è¯¯:', error);
                    showStatus('æ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                }
            };

            reader.onerror = function() {
                showStatus('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            };

            reader.readAsArrayBuffer(file);
        }

        // 2. ä»è¡¨æ ¼ä¸‹è½½Excelæ–‡ä»¶
        function saveFile() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¡¨æ ¼ä¸­æ²¡æœ‰æ•°æ®ï¼Œæ— æ³•ä¸‹è½½', 'error');
                return;
            }

            try {
                const data = hot.getData();
                const ws = XLSX.utils.aoa_to_sheet(data);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
                const fileName = currentFileName 
                    ? `${currentFileName}_å·²å¤„ç†_${timestamp}.xlsx`
                    : `å¤„ç†åçš„è¡¨æ ¼_${timestamp}.xlsx`;

                XLSX.writeFile(wb, fileName);
                showStatus(`âœ… æ–‡ä»¶"${fileName}"å·²å¼€å§‹ä¸‹è½½`, 'success');
            } catch (error) {
                console.error('ä¿å­˜é”™è¯¯:', error);
                showStatus('æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }

        // 3. æ¸…ç©ºè¡¨æ ¼
        function clearData() {
            if (hot.countRows() === 0) {
                showStatus('è¡¨æ ¼å·²ç»æ˜¯ç©ºçš„äº†', 'info');
                return;
            }
            
            if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰æ‰€æœ‰è¡¨æ ¼æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                hot.loadData([[]]);
                currentData = [];
                currentFileName = '';
                columnHeaders = [];
                document.getElementById('fileInput').value = '';
                isFormatApplied = false;
                showStatus('è¡¨æ ¼å·²æ¸…ç©º', 'success');
            }
        }

        // 4. å››ä¸ªè‡ªåŠ¨åŒ–è„šæœ¬å‡½æ•°
        function checkAge() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¯·å…ˆåŠ è½½æ•°æ®', 'error');
                return;
            }
            
            const totalRows = hot.countRows();
            let updated = 0;
            
            for (let row = 5; row < totalRows; row++) {
                // è¿™é‡Œå®ç°å¹´é¾„è®¡ç®—é€»è¾‘
                // ç¤ºä¾‹ï¼šå‡è®¾å‡ºç”Ÿæ—¥æœŸåœ¨Cåˆ—ï¼ˆç´¢å¼•2ï¼‰
                const birthDate = hot.getDataAtCell(row, 2);
                if (birthDate) {
                    const birth = new Date(birthDate);
                    const today = new Date();
                    const age = today.getFullYear() - birth.getFullYear();
                    const m = today.getMonth() - birth.getMonth();
                    
                    if (m < 0 || (m === 0 && today.getDate() < birth.getDate())) {
                        age--;
                    }
                    
                    // å‡è®¾åœ¨æœ€åä¸€åˆ—æ ‡è®°
                    const lastCol = hot.countCols() - 1;
                    hot.setDataAtCell(row, lastCol, age >= 14 ? 'æ˜¯' : 'å¦');
                    updated++;
                }
            }
            
            showStatus(`âœ… å·²æ£€éªŒ ${updated} æ¡è®°å½•çš„å¹´é¾„`, 'success');
        }

        function markLeague() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¯·å…ˆåŠ è½½æ•°æ®', 'error');
                return;
            }
            
            const totalRows = hot.countRows();
            let updated = 0;
            
            for (let row = 5; row < totalRows; row++) {
                // è¿™é‡Œå®ç°å…¥å›¢æ ‡è®°é€»è¾‘
                // ç¤ºä¾‹ï¼šå‡è®¾åœ¨ç‰¹å®šåˆ—æ ‡è®°
                const lastCol = hot.countCols() - 1;
                hot.setDataAtCell(row, lastCol, 'å¾…æ ‡è®°');
                updated++;
            }
            
            showStatus(`âœ… å·²æ ‡è®° ${updated} æ¡è®°å½•çš„å…¥å›¢çŠ¶æ€`, 'success');
        }

        function markGraduation() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¯·å…ˆåŠ è½½æ•°æ®', 'error');
                return;
            }
            showStatus('è‡ªåŠ¨æ ‡è®°æ˜¯å¦æ¯•ä¸šåŠŸèƒ½å¼€å‘ä¸­...', 'info');
        }

        function checkActivity() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¯·å…ˆåŠ è½½æ•°æ®', 'error');
                return;
            }
            showStatus('æ£€éªŒå…‰å±±å¿è·¨æ ¡ç§¯æåˆ†å­åŠŸèƒ½å¼€å‘ä¸­...', 'info');
        }

        // 5. æäº¤åŠŸèƒ½ï¼ˆè‡ªåŠ¨è·³è½¬ï¼‰
        function submitToCollectForm() {
            if (!hot || hot.countRows() === 0) {
                showStatus('è¡¨æ ¼ä¸­æ²¡æœ‰æ•°æ®ï¼Œæ— æ³•æäº¤', 'error');
                return;
            }
            
            // å†æ¬¡éªŒè¯æ ¼å¼
            const data = hot.getData();
            const validation = validateTableFormat(data);
            if (!validation.valid) {
                showStatus(validation.message, 'error');
                return;
            }
            
            if (confirm('ç¡®å®šè¦æäº¤å—ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"å°†ï¼š\n1. è‡ªåŠ¨ä¿å­˜å½“å‰è¡¨æ ¼ä¸ºExcelæ–‡ä»¶\n2. è·³è½¬åˆ°æ–‡ä»¶æ”¶é›†é¡µé¢')) {
                try {
                    saveFile();
                    
                    const collectFormUrl = 'https://f.wps.cn/g/JaaWyioV/'; // æ›¿æ¢ä¸ºä½ çš„æ”¶é›†è¡¨é“¾æ¥
                    
                    setTimeout(() => {
                        window.open(collectFormUrl, '_blank');
                        showStatus('å·²è·³è½¬åˆ°æ”¶é›†è¡¨é¡µé¢ï¼è¯·åœ¨æ‰“å¼€çš„é¡µé¢ä¸­ä¸Šä¼ åˆšåˆšä¸‹è½½çš„æ–‡ä»¶ã€‚', 'success');
                    }, 1000);
                    
                } catch (error) {
                    showStatus('æäº¤è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¯·é‡è¯•', 'error');
                }
            }
        }

        // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveFile();
            }
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                document.getElementById('fileInput').click();
            }
        });
    </script>
</body>
</html>
